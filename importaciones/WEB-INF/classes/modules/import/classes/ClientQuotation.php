<?php

require_once('import/classes/ClientQuotationHistory.php');
require_once('import/classes/ClientQuotationHistoryPeer.php');
require_once 'import/classes/om/BaseClientQuotation.php';


/**
 * Skeleton subclass for representing a row from the 'import_clientQuotation' table.
 *
 * Cotizacion a Cliente
 *
 * This class was autogenerated by Propel on:
 *
 * Mon Feb  2 17:02:11 2009
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    anmaga
 */
class ClientQuotation extends BaseClientQuotation {

	//estados internos del objeto
	const STATUS_NEW = 1;
	const STATUS_SUPPLIER_QUOTATION_REQUESTED = 2;
	const STATUS_WAITING_FOR_PRICING = 3;
	const STATUS_PARTIALLY_QUOTED = 4;
	const STATUS_QUOTED = 5;
	
	//nombre de los estados para los clientes
	private $statusNamesClient = array(
								ClientQuotation::STATUS_NEW => 'New',
								ClientQuotation::STATUS_SUPPLIER_QUOTATION_REQUESTED => 'In Progress',
								ClientQuotation::STATUS_WAITING_FOR_PRICING => 'In Progress',
								ClientQuotation::STATUS_PARTIALLY_QUOTED => 'Partially Quoted',
								ClientQuotation::STATUS_QUOTED => 'Quoted',
							);

	//nombre de los estados para los administradores
	private $statusNamesAdmin = array(
								ClientQuotation::STATUS_NEW => 'New',
								ClientQuotation::STATUS_SUPPLIER_QUOTATION_REQUESTED => 'Quotation Requested',
								ClientQuotation::STATUS_WAITING_FOR_PRICING => 'Waiting For Pricing',
								ClientQuotation::STATUS_PARTIALLY_QUOTED => 'Waiting For Pricing',
								ClientQuotation::STATUS_QUOTED => 'Quoted',
							);							

	/**
	 * Devuelve un array con los nombres de los distintos mensajes de status para el afiliado/cliente
	 * @return array
	 */	
	public function getStatusNamesClient() {
		return $this->statusNamesClient;
	}

	/**
	 * Devuelve un array con los nombres de los distintos mensajes de status para el adminstrador
	 * @return array
	 */
	public function getStatusNamesAdmin() {
		return $this->statusNamesAdmin;
	}
	
	
	/**
	 * El cliente confirma que el contenido de la cotizacion esta listo para ser cotizado por anmaga.
	 * Internamente la cotizacion para de estado NEW a estado Waiting For Response
	 * @return boolean
	 */
	public function clientConfirm() {
		
		try {

			if ($this->getStatus() != ClientQuotation::STATUS_NEW) {
				return false;
			}

			$this->setStatus(ClientQuotation::STATUS_SUPPLIER_QUOTATION_REQUESTED);
			$this->save();
			
			$this->saveCurrentStatusOnHistory();
			
		} catch (PropelException $e) {
			return false;
		}
		
		return true;
		
	}

	/**
	 * El cliente cierra la cotizacion, confirmando sus precioas al cliente .
	 * Internamente la cotizacion pasa al estado QUOTED
	 * @return boolean
	 */
	public function close() {
		
		try {

			if ($this->getStatus() != ClientQuotation::STATUS_PARTIALLY_QUOTED) {
				return false;
			}

			$this->setStatus(ClientQuotation::STATUS_QUOTED);
			$this->save();
			
			$this->saveCurrentStatusOnHistory();
			
		} catch (PropelException $e) {
			return false;
		}
		
		return true;
		
	}
	
	/**
	 * Indica si la cotizacion se encuentra en espera de respuesta.
	 * @return boolean
	 */
	public function isWaitingResponse() {
		return (($this->getStatus() == ClientQuotation::STATUS_SUPPLIER_QUOTATION_REQUESTED) ||($this->getStatus() == ClientQuotation::STATUS_WAITING_FOR_PRICING) || ($this->getStatus() == ClientQuotation::STATUS_PARTIALLY_QUOTED));
	}

	/**
	 * Indica si la cotizacion se encuentra recien creada.
	 * @return boolean
	 */
	public function isNewStatus() {
		return ($this->getStatus() == ClientQuotation::STATUS_NEW);
	}

	/**
	 * Indica si la cotizacion se encuentra contestada parcialmente.
	 * @return boolean
	 */
	public function isPartiallyQuoted() {
		return ($this->getStatus() == ClientQuotation::STATUS_PARTIALLY_QUOTED);
	}

	
	/**
	 * Devuelve el nombre del status actual de la cotizacion para un administrador
	 * @return string
	 */
	public function getStatusNameAdmin() {
		return $this->statusNamesAdmin[$this->getStatus()];
	}

	/**
	 * Devuelve el nombre del status actual de la cotizacion para un cliente
	 * @return string
	 */
	public function getStatusNameClient() {
		return $this->statusNamesClient[$this->getStatus()];
	}	

	/**
	 * Obtiene un cierto elemento de la cotizacion
	 * @param integer $id id del elemento a obtener
	 */
	public function getClientQuotationItem($id) {
		$criteria = new Criteria();
		$criteria->add(ClientQuotationItemPeer::CLIENTQUOTATIONID,$this->getId());
		$criteria->add(ClientQuotationItemPeer::ID,$id);
		
		$result = $this->getClientQuotationItems($criteria);
		return $result[0];
	}
	
	/**
	 * Saves the current status of the instance in his history
	 * @return boolean
	 */
	public function saveCurrentStatusOnHistory() {
		
		require_once('ClientQuotationHistory.php');
		
		try {

			$clientQuotationHistory = new ClientQuotationHistory();
			$clientQuotationHistory->setClientQuotation($this);
			$clientQuotationHistory->setStatus($this->getStatus());
			$clientQuotationHistory->setCreatedAt(time());
			$clientQuotationHistory->save();
			
		} catch (Exception $e) {
			return false;
		}
		
		return true;
	}

	/**
	 * Indica si la cotizacion se encuentra cerrada
	 * @return boolean
	 */
	public function isQuoted() {
		return ($this->getStatus() == ClientQuotation::STATUS_QUOTED);
	}
	
	/**
	 * Obtiene aquellos items de la orden
	 * que un cierto proveedor tiene disponibles
	 * @param Supplier $supplier instancia de proveedor
	 * @return array
	 */
	public function getClientQuotationItemsBySupplier($supplier) {
		
		require_once('ClientQuotationItemPeer.php');
		
		$criteria = new Criteria();
		$criteria->addJoin(ClientQuotationItemPeer::PRODUCTID,ProductSupplierPeer::PRODUCTID,Criteria::INNER_JOIN);
		$criteria->add(ClientQuotationItemPeer::CLIENTQUOTATIONID,$this->getId());
		$criteria->add(ProductSupplierPeer::SUPPLIERID,$supplier->getId());

		return ClientQuotationItemPeer::doSelect($criteria);
		
	}
	
	/**
	 * Obtiene los proveedores que estan relacionados a los productos que tiene la cotizacion
	 * @return array array de instancias de supplier
	 */
	public function getProductRelatedSuppliers() {
		
		require_once('SupplierPeer.php');
		
		$criteria = new Criteria();
		$criteria->addJoin(SupplierPeer::ID,ProductSupplierPeer::SUPPLIERID,Criteria::INNER_JOIN);
		$criteria->addJoin(ProductSupplierPeer::PRODUCTID,ClientQuotationItemPeer::PRODUCTID,Criteria::INNER_JOIN);
		$criteria->add(ClientQuotationItemPeer::CLIENTQUOTATIONID,$this->getId());
		$criteria->setDistinct();
		
		return SupplierPeer::doSelect($criteria);
	}
	
} // ClientQuotation
