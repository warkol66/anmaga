<?php
require_once 'om/BaseNode.php';
include_once 'TreePeer.php';

/** 
 * The skeleton for this class was autogenerated by Propel  on:
 *
 * [02/28/07 13:26:08]
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package sipro 
 */
class Node extends BaseNode {

	/*
	* Obtiene el subarbol del nodo.
	*
	* @return array Subarbol
	*/
	function getSubTree() {
		return $this->getAllChilds();
	}
	
	/*
	* Obtiene el subarbol del nodo solo con los nodo del tipo especificado.
	*
	*	@param string $kind Tipo de nodo
	* @return array Subarbol
	*/
	function getSubTreeOnlyKind($kind) {
		return $this->getAllChildsOnlyKind($kind);
	}
	
	/*
	* Obtiene todos los hijos del nodo y los hijos de los hijos.
	*
	* @return array Subarbol
	*/
	function getAllChilds() {
	  //Obtengo todos los hijos del nodo
		$childs = $this->getChilds();
		//Obtengo recursivamente todos los hijos de cada hijo
		$childsArray = array();
		foreach ($childs as $child) {
			$childsElement = array();
			$childsElement["node"] = $child;
			$childsElement["childs"] = $child->getAllChilds();
			$childsArray[] = $childsElement;
		}
		return $childsArray;
	}
	
	/*
	* Obtiene todos los hijos del nodo y los hijos de los hijos.
	*
	*	@param string $kind Tipo de nodo
	* @return array Subarbol
	*/
	function getAllChildsOnlyKind($kind) {
	  //Obtengo todos los hijos del nodo
		$childs = $this->getChildsOnlyKind($kind);
		//Obtengo recursivamente todos los hijos de cada hijo
		$childsArray = array();
		foreach ($childs as $child) {
			$childsElement = array();
			$childsElement["node"] = $child;
			$childsElement["childs"] = $child->getAllChildsOnlyKind($kind);
			$childsArray[] = $childsElement;
		}
		return $childsArray;
	}

	/*
	* Obtiene todos los hijos del nodo
	*
	* @return array Todos los nodos hijos.
	*/
	function getChilds() {
	  //Obtengo todos los hijos del nodo
		$cond = new Criteria();
		$cond->add(NodePeer::PARENTID, $this->id);
		$childs = NodePeer::doSelect($cond);
		return $childs;
	}
	
	/*
	* Obtiene todos los hijos del nodo de un tipo
	*
	*	@param string $kind Tipo de nodo
	* @return array Todos los nodos hijos.
	*/
	function getChildsOnlyKind($kind) {
	  //Obtengo todos los hijos del nodo
		$cond = new Criteria();
		$cond->add(NodePeer::PARENTID, $this->id);
		$cond->add(NodePeer::KIND, $kind);
		$childs = NodePeer::doSelect($cond);
		return $childs;
	}
	
	/*
	* Obtiene todos los hijos del nodo de un tipo paginados
	*
	*	@param string $kind Tipo de nodo
	* @param int $page [optional] Numero de pagina actual
	* @param int $perPage [optional] Cantidad de elementos por pagina
	* @return array Todos los nodos hijos.
	*/
	function getChildsOnlyKindPaginated($kind,$page=1,$perPage=10) {
		if (empty($page))
			$page = 1;
		require_once("propel/util/PropelPager.php");
		$cond = new Criteria();
		$cond->add(NodePeer::PARENTID, $this->id);
		$cond->add(NodePeer::KIND, $kind);

		$pager = new PropelPager($cond,"NodePeer", "doSelect",$page,$perPage);
		return $pager;
	}
	
	/*
	* Obtiene todos los productos del nodo paginados
	*
	* @param int $page [optional] Numero de pagina actual
	* @param int $perPage [optional] Cantidad de elementos por pagina
	* @return array Todos los nodos hijos.
	*/
	function getChildsProductsPaginated($page=1,$perPage=10) {
		if (empty($page))
			$page = 1;
		require_once("propel/util/PropelPager.php");
		$cond = new Criteria();
		$cond->add(NodePeer::PARENTID, $this->id);
		$cond->add(NodePeer::KIND, "Product");
		$cond->addJoin(NodePeer::OBJECTID, ProductPeer::ID);
		$cond->add(ProductPeer::ACTIVE, true);		

		$pager = new PropelPager($cond,"NodePeer", "doSelect",$page,$perPage);
		return $pager;
	}	
	
	/*
	* Obtiene la informacion particular de ese nodo.
	*
	* @return NodeKind Objeto asociado al nodo
	*/
	function getInfo() {
		require_once($this->getKind()."Peer.php");
		$peer = $this->getKind()."Peer";
		$peerObject = new $peer;
   		$object = $peerObject->retrieveByPK($this->getObjectId());
		return $object;
	}
	
	/*
	* Obtiene el nodo padre del nodo.
	*
	* @return Node Nodo padre
	*/
	function getParentNode() {
		return NodePeer::get($this->getParentId());
	}
	
	/**
	* Elimina el nodo y su subarbol, como asi tambien toda la informacion asociada a los nodos.
	*
	*	@return boolean true
	*/
	function deleteWithSubTree() {
		$childs = $this->getChilds();
		//elimino los hijos
		foreach ($childs as $child) {
				$child->deleteWithSubTree();
		}
		//elimino el objeto asociado
		$info = $this->getInfo();
		$info->delete();
		//y finalmente elimino el nodo
		$this->delete();
		return true;
	}
	
	
	/**
	 * obtiene los hijos de un cierto nodo
	 *
	 * @param $kind tipo de hijo
	 * @param $page numero de pagina a obtener.
	 *
	 */
	function getChildsOnlyKindPaginatedAffiliate($kind,$page=1) {
		$perPage = 	TreePeer::getRowsPerPage();
		if (empty($page))
			$page = 1;
		require_once("propel/util/PropelPager.php");
		$cond = new Criteria();
		$cond->add(NodePeer::PARENTID, $this->getId());
		$cond->add(NodePeer::KIND, $kind);
		$cond->add(AffiliateProductPeer::AFFILIATEID, Common::getAffiliatedId());
		$cond->addJoin(NodePeer::ID , AffiliateProductPeer::PRODUCTID, Criteria::JOIN);
		$cond->addJoin(NodePeer::OBJECTID, ProductPeer::ID);
		$cond->add(ProductPeer::ACTIVE, true);				
		
		$pager = new PropelPager($cond,"NodePeer","doSelect",$page,$perPage);
		
		
		return $pager;
	
	}
	
	




}
